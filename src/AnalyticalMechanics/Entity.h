/*
 <one line to give the library's name and an idea of what it does.>
 Copyright (C) 2013  Guillaume <email>
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

//! \file Entity.h definition of the class Entity, msVectorOfDofs, and msVectorOfPtrDof and msKineticWork

#ifndef ENTITY_H
#define ENTITY_H

#include <ResourceManager.h>

namespace atomism {
    
    
	
    /** \class Entity
     *
     * \brief Describes the mass repartition with respect to (abstract) degrees of freedom
     *
     * The purpose of Entity is to compute the position of ponctual masses w/ degrees of freedom (DoF).
     * The meaning of the DoF are abstract here: this is the purpose of derived classes to
     * link the DoFs to the mass's position (for instance cartesian coordinates or z-matrix).
     * The Entity class ensures that all the displacments generated by a modification of the Dofs
     * conserve the linear and angular momentum. Hence, derived class just have to ensure
     * the correct computation of the relative position of the elements (see Entity::updatePositions).
     *
     * The class obeys to the curiously recurring template pattern to avoid virtual method calls.
     */
    template<
    typename DerivedClass,
    typename Scalar           = double,
    typename Vector           = std::vector<Scalar>,
    typename Matrix 	      = std::vector<std::vector<Scalar>>,
    typename Positions 	      = std::tuple<Vector&,Vector&,Vector&>,
    typename Vector3d         = std::array<Scalar,3>,
    typename Matrix3d         = std::array<Vector3d,3>
    >
    class Entity {
        
    public:
           
        //! number of elements
        size_t noOfElements()     const { return static_cast<const DerivedClass*>(this)->noOfElements(); };
        
        //! number of Dof
        size_t noOfDofs()         const { return static_cast<const DerivedClass*>(this)->noOfDofs(); };
	    
	//! masse of the elements [kg]
	const Vector& getMasses() const { return _MassElements;};
	
	//! @name compute methods
        //@{
	    /** \brief computes the relative positions
	     * 
	     * This method needs to be defined in derived class.
	     * 
	     * \param dofsValues values of the degrees of freedom
	     * \param positions output: coordinates of the elements
	     */	  
	void computeRelativePositions(const Vector& dofsValues,
				      Positions&    positions ) const {
	    ATOMISM_THROW_VIRTUAL();
	};
				      
	    /** \brief computes the cartesian coordinates
	     *
	     * This method calls Derived->computeRelativePositions.
	     * If _Isolated, it applies overall transformations
	     * to ensure linear and angular momentum conservation.
	     * \param dofsValues values of the degrees of freedom
	     * \param positions output: coordinates of the elements
	     */
        void computeCoordinates( const Vector& dofsValues, 
				 Positions& positions)   const;

	    /** \brief computes the element's displacments to reach new Dofs 
	     *
	     * \param coors0 initial positions
	     * \param dofsNew 'new' degrees of freedom
	     * \param displacments output: displacments
	     */
	void computeDisplacments(const Positions& coors0,
				 const Vector& dofsNew,
			         Positions& displacments) const;
	
	    /** \brief compute the jacobian of the displacments
	     *
	     * Compute the displacments generated by each degrees of freedom and 
	     * fill the matrix  'jacOfDisplX/Y/Z'.
	     * This method can be rediplemented in derived class for better 
	     * performance.
             *
	     * \param coors0 initial positions
	     * \param dofsNew 'new' degrees of freedom
	     * \param displacments output: displacments
	     */			 
        void computeJacobian(const Vector& dofsValues,
                             const Vector& dq,
		             Matrix&       jacOfDisplX,
		             Matrix&       jacOfDisplY,
		             Matrix&       jacOfDisplZ
		             ) const;
       //@}
        
    protected:
        
	    
        Entity(std::shared_ptr<ResourceManager<Scalar,Vector,Matrix>> resource);
                
        /** \brief set the masses
	 *
	 * \param mass mass of the elements in [kg]
	 */
        void initElements(Vector masses) { _MassElements=masses; };
	
        //! This is used to create/obtain new elements within thread safety.
        mutable std::shared_ptr<ResourceManager<Scalar,Vector,Matrix> > _ResourceMngr;
					      
    private:
             
        Entity();
      
	Vector _MassElements; //!< mass of the elements in kg
	    
        Scalar _Mass; 	      //!< total mass in kg
	
        //! \brief Apply a translation to 'Pos1' so that no linear momentum is generated by the displacments from Pos0 to Pos1
        void annihilLinearMomentum(const Positions& Pos0, Positions& Pos1) const;
        
        //! \brief Apply a rotation to 'Pos1' so that no angular momentum is generated by the displacments from Pos0 to Pos1
        void annihilAngularMomentum(const Positions& Pos0, Positions& Pos1) const;
	    
	    
        double dteta   = 0.01;
        double epsRel  = 1e-10 ;
        double epsAbs  = 1e-10 ;
        int    MaxStep = 50;
        bool _Isolated = 1;
	
    };
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename DerivedClass, typename Scalar, typename Vector, typename Matrix, typename Positions,
    typename Vector3d,typename Matrix3d>
    inline 
    Entity<DerivedClass,Scalar,Vector,Matrix,Positions,Vector3d,Matrix3d>::
    Entity() {
        
        ATOMISM_LOG();
    };
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename DerivedClass, typename Scalar, typename Vector, typename Matrix, typename Positions,
    typename Vector3d,typename Matrix3d>
    inline 
    Entity<DerivedClass,Scalar,Vector,Matrix,Positions,Vector3d,Matrix3d>::
    Entity(std::shared_ptr<ResourceManager<Scalar,Vector,Matrix>> resource) {
        
        ATOMISM_LOG();
	_ResourceMngr = resource;
    };
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename DerivedClass, typename Scalar, typename Vector, typename Matrix, typename Positions,
    typename Vector3d,typename Matrix3d>
    inline
    void Entity<DerivedClass,Scalar,Vector,Matrix,Positions,Vector3d,Matrix3d>::
    computeCoordinates(const Vector& dofsValues, 
		       Positions& positions) const {
        
        ATOMISM_LOG();
	
        static_cast<const DerivedClass*>(this)->computeRelativePositions(dofsValues, positions);
	
    }
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename DerivedClass, typename Scalar, typename Vector, typename Matrix, typename Positions,
    typename Vector3d,typename Matrix3d>
    inline
    void Entity<DerivedClass,Scalar,Vector,Matrix,Positions,Vector3d,Matrix3d>::
    computeDisplacments(const Positions& coors0,
                        const Vector& DofsNew,
                        Positions& displacments) const {
        
        ATOMISM_LOG();
        
        static_cast<const DerivedClass*>(this)->computeRelativePositions(DofsNew, displacments);
	
	if( _Isolated) {
            annihilLinearMomentum( coors0 , displacments );
            annihilAngularMomentum( coors0 , displacments );
	}
	
        displacments -= coors0;
    }
    
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename DerivedClass, typename Scalar, typename Vector, typename Matrix, typename Positions,
    typename Vector3d,typename Matrix3d>
    inline
    void Entity<DerivedClass,Scalar,Vector,Matrix,Positions,Vector3d,Matrix3d>::
    annihilLinearMomentum(const Positions& coors0,
                          Positions& coors1) const {
        
        ATOMISM_LOG();
        
        Vector3d Momentum = totalLinearMomentum<Vector,Vector3d,Positions>( coors0, coors1, _MassElements);
        translate( coors1, -1. * Momentum);
        
        LOGGER_WRITE(Logger::DEBUG,stringstream("Delta CDG: ")
                     <<-Momentum[0]<<" "<<-Momentum[1]<<" "<<-Momentum[2]);
        
    }
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename DerivedClass, typename Scalar, typename Vector, typename Matrix, typename Positions,
    typename Vector3d,typename Matrix3d>
    inline
    void Entity<DerivedClass,Scalar,Vector,Matrix,Positions,Vector3d,Matrix3d>::
    annihilAngularMomentum(const Positions& coors0,
                           Positions&       coors1) const {
        
        ATOMISM_LOG();
        ATOMISM_VALUE_MISMATCH( [&](){return n_elements(coors0);},
	                        [&](){return noOfElements();});
	
        ATOMISM_VALUE_MISMATCH( [&](){return n_elements(coors0);},
	                        [&](){return n_elements(coors1);});
	
        int    n_it        = 0;
        double conv,teta   = 1;
        
        Vector3d axe,dJ_ext,dJ;
        Matrix3d rotMatrix;/*
        dJ = totalAngularMomentum(coors0,coors1,_MassElements);
	
	std::array<string,4> heads={"it","dEc","dJ","dP"};
        LOGGER_WRITECOLUMNS( heads );
        
        while( dJ>epsAbs ) {
            
	   // LOGGER_WRITE4COLUMNS(msLogger::DEBUG, n_it,dEkin,norm(dJ),norm(dP));
            
            dJ_ext = totalAngularMomentum(coors1, rotationMatrix(dteta,dJ),_MassElements);
            
            rotate( coors1, rotationMatrix(-dteta*dot(dJ,dJ_ext)/norm(dJ), dJ) );

            n_it++;
            if (n_it<MaxStep) break;
         }
        */
        ATOMISM_EXCEPT_IF( [&](){return  n_it>=MaxStep;});
        
    }
     
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename DerivedClass, typename Scalar, typename Vector, typename Matrix, typename Positions,
    typename Vector3d,typename Matrix3d>
    inline 
    void Entity<DerivedClass,Scalar,Vector,Matrix,Positions,Vector3d,Matrix3d>::
    computeJacobian(const Vector& dofsValues,
                    const Vector& dq,
		    Matrix&       jacOfDisplX,
		    Matrix&       jacOfDisplY,
		    Matrix&       jacOfDisplZ
		    ) const {
    
        ATOMISM_LOG();
        ATOMISM_VALUE_MISMATCH( [&](){return atomism::n_elements(dq);},
	                        [&](){return atomism::n_elements(dofsValues);});
	
	ATOMISM_VALUE_MISMATCH( [&](){return atomism::n_elements(dq)*noOfDofs();},
	                        [&](){return atomism::n_elements(jacOfDisplX);});
	
	ATOMISM_VALUE_MISMATCH( [&](){return atomism::n_elements(jacOfDisplX);},
	                        [&](){return atomism::n_elements(jacOfDisplY);});
	
	ATOMISM_VALUE_MISMATCH( [&](){return atomism::n_elements(jacOfDisplX);},
	                        [&](){return atomism::n_elements(jacOfDisplZ);});
	
	auto positions = _ResourceMngr->requestPositions(noOfElements());
	auto jacOfDofs = _ResourceMngr->requestMatrix(noOfDofs(),noOfDofs());
	
        computeCoordinates(dofsValues, *positions);
	
	replicate_vector( dofsValues , *jacOfDofs );
	increment_diagonal( dq       , *jacOfDofs );
	
        for(int i = 0; i < noOfDofs() ; ++i) {
            
            //can be executed concurently using resource.noOfThread()
	    auto tuple = std::tie(slice(i,jacOfDisplX),
	  	                  slice(i,jacOfDisplY),
				  slice(i,jacOfDisplZ));
	    computeDisplacments( *positions , slice(i,*jacOfDofs) , tuple);
	}

    }

    
}
#endif // MSENTITY_H
