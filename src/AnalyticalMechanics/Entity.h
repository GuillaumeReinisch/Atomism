/*
 <one line to give the library's name and an idea of what it does.>
 Copyright (C) 2013  Guillaume <email>
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

//! \file Entity.h definition of the class Entity, msVectorOfDofs, and msVectorOfPtrDof and msKineticWork

#ifndef ENTITY_H
#define ENTITY_H


namespace atomism {
        
        
	typedef Vector3D eigen::Vector3d;
	typedef Matrix3D eigen::Matrix3d;
	
        /** \class Entity
         *
         * \brief Describes the mass repartition with respect to (abstract) degrees of freedom
         *
         * The purpose of Entity is to compute the position of ponctual masses w/ degrees of freedom (DoF).
	 * The meaning of the DoF are abstract here: this is the purpose of derived classes to 
	 * link the DoFs to the mass's position (for instance cartesian coordinates or z-matrix).
	 * The Entity class ensures that all the displacments generated by a modification of the Dofs
	 * conserve the linear and angular momentum. Hence, derived class just have to ensure
	 * the correct computation of the relative position of the elements (see Entity::updatePositions).
	 *
	 * The class obeys to the curiously recurring template pattern to avoid virtual method calls.
         */
	template<typename ScalarType=double,
	         typename VectorType=std::vector<ScalarType>,
		 DerivedClass 
		 >
        class Entity {
	  	    
	  
		    /** \class KineticWork
		     *
		     * The purpose of this class is to compute the kinetic work generated
		     * by a displacments of the pontcual masses.
		     */ 
	           template<typename ScalarType=double,
		            typename VectorType=std::vector<ScalarType> 
		            >
	           class KineticWork {
        
		   friend class Entity;
		   
		   public:
		     
		      msKineticWork(){};
		      
		      /** \brief compute the kinetic work
		       * 
		       * \param X0-Y0-Z0 X, Y, Z coordinates of the elements at t0
		       * \param X1-Y1-Z1 X, Y, Z coordinates of the elements at t1
		       * \param Masses Mass of the elements 
		       */ 
		      void set(     const VectorType& X0,const VectorType& Y0,const VectorType& Z0,
			            const VectorType& X1,const VectorType& Y1,const VectorType& Z1,
				    const VectorType& Masses
			      );
		   private:
                       		       
                       Vector3d dP;  	 //!< linear momentum generated by the displacments
		       
                       Vector3d dJ;  	 //!< angular momentum generated by the displacments
		       
                       ScalarType dEkin; //!< kinetic energy generated by the displacments
		   };
        public:
            
            //! @name set methods
            //@{
            //! set the Dof number 'i' to a value 'd'
            void setDof(size_t i,double d);
            
            //! return a the Dof number 'i'
            double getDof(size_t i) const;
            
            //! number of elements
            size_t noOfElements() const;
            
            //! number of Dof
            size_t noOfDof()      const;
            
            //@}
	    
            //-----------------------------------------------------
	    //-----------------------------------------------------
	    
	    //! @name get methods
            //@{
            //! return the position of the element 'i'
            Vector3d getPosition(size_t i) const;
            
            //! return the mass of the entity
            double getMass() const;
            
            //@}
	    
	    //-----------------------------------------------------
	    //-----------------------------------------------------
	    
	    //! @name compute methods
            //@{
	    
	    /** \brief computes the cartesian coordinates 
	     * 
	     * This method calls Derived->updatePosition and apply overall transformations
	     * to ensure linear and angular momentum conservation.
	     */
            KineticWork computeCartesianCoordinates();
	    
	    
	    KineticWork displace( const VectorType& dDofs );
	    
            /** \brief computes compute the principal moment of inertia.  
	     *
	     * \param eigenvalues  stores the norms
	     * \param eigenvectors stores the directions, if zero the eigenvectors are not returned
	     */
            void computeEigenInertia(Vector3d* eigenvalues,Matrix3d* eigenvectors = 0) const;    
	                
	    //@}
	      
   	    //! @name geometry analysis
            //@{
	    //! return the separation between the elements i, j
            double separation(size_t i,size_t j);
            
            //! return the angle between the elements i, j, k
            double angle(size_t i,size_t j,size_t k);
            
            //! return the dihedral angle between the elements i, j, k, l
            double dihedral(size_t i,size_t j,size_t k,size_t l);
	    //@}
	    
        protected:
            
	    //! @name construction
            //@{
	    
            Entity();
            
            /** \brief add an element
	     * 
	     * \param mass mass of the elements in [amu]
	     */
            void addElement(double mass);
            
            /** \brief add a degree of freedom
	     * 
	     * \param value initial value of the Dof, angles are in [radian], lengths in [Angstrom]
             */
            void addDof(double value);
	    
            //@}
	         
        private:
            
            //! Store the DoF of the structure
            VectorType Dofs;	  
            
	    //! Store the mass of the elements in amu
	    VectorType MassElements;
	    
	    //! X positions of the Elements
	    VectorType X;
	    
	    //! Y positions of the Elements
	    VectorType Y;
	    
	    //! Z positions of the Elements 
	    VectorType Z;
	    
	    //! Stores the overall translation vector to ensure conservation of the linear momentum
            Vector3d OverallTranslation;
            
	    //! Stores the overall rotation matrix to ensure conservation of the angular momentum
            Matrix3d OverallRotation;
	    
	     /** \brief Apply a translation to 'Coors1' so that no linear momentum is generated by the displacments from Coors0 to Coors1
             */
            void annihil_dP(const VectorType& X0, const VectorType& Y0, const VectorType& Z0,
                            VectorType& X1, const VectorType& Y1, const VectorType& Z1);
            
            /** \brief Apply a rotation to 'Coors1' so that no angular momentum is generated by the displacments from Coors0 to Coors1
             */    
            KineticWork annihil_dJ(const VectorType& X0, const VectorType& Y0, const VectorType& Z0,
                                     VectorType& X1, const VectorType& Y1, const VectorType& Z1);
	    
	    /** \brief update the relative position of the elements
	     * 
	     * This needs to be defined in derived class.
	     */ 
            void updatePositions() { 
	      
	       static_cast<Derived*>(this)->updatePositions(X,Y,Z);
	    }; 
	    
        };
      
       
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

    template< typename ScalarType=double,
	      typename VectorType=std::vector<ScalarType>,
	      DerivedClass 
	      >
    inline  
    KineticWork Entity::computeCartesianCoordinates() { 
	      
        ATOMISM_LOGIN();  //Anything about logging can be removed by configuration
	
	VectorType X1 = atomism::zero_clone(X);
	VectorType Y1 = atomism::zero_clone(Y);
	VectorType Z1 = atomism::zero_clone(Z);
	
        // update the relative positions of the elements -> implemented by DerivedClass
	// X1, Y1, Z1 are the new relative position of the atoms
        static_cast<DerivedClass*>(this)->updatePositions(X1,Y1,Z1);
	
	// apply the correct overall translation to ensure conservation of linear momentum
        annihil_dP(X,Y,Z,X1,Y1,Z1);    
	
	// apply the correct overall rotation to ensure conservation of angular momentum
	KineticWork<ScalarType> work = annihil_dJ(X,Y,Z,X1,Y1,Z1);
	
	ATOMISM_LOGOUT();
        return work;       
   };
   
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
        
    template< typename ScalarType=double,
	      typename VectorType=std::vector<ScalarType>,
	      DerivedClass 
	      >
    inline
    KineticWork Entity::displace( VectorType dDofs ){
      
        ATOMISM_LOGIN();
	ATOMISM_EXCEPT_IF( [&](){return  dDofs.size()!=Dofs.size();},
			  "dDofs and Entity::Dofs are not of the same size");
	
	Dofs = Dofs + dDofs;
	KineticWork<ScalarType> work = computeCartCoordinates();
	
        ATOMISM_LOGOUT();   
	return work;
    }
    
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

    template< typename ScalarType=double,
	      typename VectorType=std::vector<ScalarType>,
	      DerivedClass 
	      >
    inline 
    void Entity::annihil_dP(const VectorType& X0, const VectorType& Y0, const VectorType& Z0,
                             VectorType& X1, VectorType& Y1, VectorType& Z1) {
      
        ATOMISM_LOGIN();
	
        ATOMISM_EXCEPT_IF( [&](){return (X0.size()!=Y0.size()) || (X0.size!=Z0.size())
				     || (X1.size()!=Y1.size()) || (X1.size!=Z1.size())
				     || (X0.size()!=X1.size()) || (X0.size()!=noOfElements()) ;},
				"Problem with the size of X, Y, Z vectors" );
	
	ATOMISM_EXCEPT_IF( [&](){return MassElements.size()!=noOfElements();},
				"MassElements.size() != noOfElements()" );
	
	// Is there any way to do the three following sum at the same time ?
	Vector3d Cdg0 = Vector3d( sum( MassElements * X0) , 
				  sum( MassElements * Y0) , 
				  sum( MassElements * Z0) ); 
	
	Vector3d Cdg1 = Vector3d( sum( MassElements * X1) , 
				  sum( MassElements * Y1) , 
				  sum( MassElements * Z1) ); 
	
	// should I use VEX_CONSTANT ?
	X1 -=  Cdg1[0] - Cdg0[0];
	Y1 -=  Cdg1[1] - Cdg0[1];
	Z1 -=  Cdg1[2] - Cdg0[2];
	
	OverallTranslation += Cdg1 - Cdg0;
	
	LOGGER_WRITE(Logger::DEBUG,stringstream("Delta CDG: ")
		     <<OverallTranslation[0]<<" "
		     <<OverallTranslation[1]<<" "
		     <<OverallTranslation[2]);
	
        ATOMISM_LOGOUT();
    }	
   
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
        
    template< typename ScalarType=double,
	      typename VectorType=std::vector<ScalarType>,
	      DerivedClass 
	      >
    inline    
    KineticWork Entity::annihil_dJ(const VectorType& X0, const VectorType& Y0, const VectorType& Z0,
				   VectorType& X1, VectorType& Y1, VectorType& Z1) {
      
        ATOMISM_LOGIN();
            
	ATOMISM_EXCEPT_IF( [&](){return (X0.size()!=Y0.size()) || (X0.size!=Z0.size())
				     || (X1.size()!=Y1.size()) || (X1.size!=Z1.size())
				     || (X0.size()!=X1.size()) || (X0.size()!=noOfElements()) ;},
				"Problem with the size of X, Y, Z vectors" );
	
	ATOMISM_EXCEPT_IF( [&](){return MassElements.size()!=noOfElements();},
				"Entity::MassElements.size() != Entity::noOfElements()" );
	
        double dteta   = 0.01;  
	double epsRel  = 1e-10 ;
	double epsAbs  = 1e-10 ;
        int    MaxStep = 50;
	int    n_it    = 0;
	double error   = 1;
	
	Vector3d axe,dJ_ext;
	Matrix3d dMatRot;
            
	VectorType tmpX  = atomism::zero_clone(X);
	VectorType tmpY  = atomism::zero_clone(X);
	VectorType tmpZ  = atomism::zero_clone(X);
	VectorType tmp2X = atomism::zero_clone(X);
	VectorType tmp2Y = atomism::zero_clone(X);
	VectorType tmp2Z = atomism::zero_clone(X);
	
	LOGGER_WRITE(Logger::DEBUG,
		     std::stringstream("Max number of step: ")<<MaxStep
		     <<"; relative residu: "<<epsRel<<"; absolu residu: "<<epsAbs);
	
	LOGGER_HEADER4COLUMNS(msLogger::DEBUG,"it","dEc","dJ","dP");	
	
	KineticWork<ScalarType> KinWork(X0,Y0,Z0,X1,Y1,Z1,MassElements);
	            
	// the sum function will be deported somewhere else, for now it's here
	vex::Reductor<double, vex::SUM> sum( X0.queue_list() );
	
        while( (KinWork.dJ.norm() > epsAbs) && (error > epsRel) ) {
                
	        LOGGER_WRITE4COLUMNS(msLogger::DEBUG,
				     n_it,KinWork.dEkin,KinWork.dJ.norm(),KinWork.dP.norm());
		
                axe = KinWork.dJ;
                dMatRot = Eigen::AngleAxisd(dteta,axe.normalize());
		
		// I want to do for each element i: Vector3d tmp = dMatRot*Coors1[i] - Coors1[i] 
		// where Coors1=Vector3D(X1[i],Y1[i],Z1[i])
		
		tmpX = dMatRot[0][0]*X1 + dMatRot[0][1]*Y1 + dMatRot[0][2]*Z1 - X1;
		tmpY = dMatRot[1][0]*X1 + dMatRot[1][1]*Y1 + dMatRot[1][2]*Z1 - Y1;
		tmpZ = dMatRot[2][0]*X1 + dMatRot[2][1]*Y1 + dMatRot[2][2]*Z1 - Z1;
		
		// now I want to do is: Coors1[i].outter_product(tmp[i]) for each i 
		tmp2X = Y1*tmpZ-Z1*tmpY;
		tmp2Y = X1*tmpZ-Z1*tmpX;
		tmp2Z = X1*tmpY-Y1*tmpX;
		
		dJ_ext = Eigen::Vector3d( sum(tmp2X), sum(tmp2Y), sum(tmp2Z) );
		
                double teta = dteta * KinWork.dJ.norm() / dJ_ext.norm();
		
                if( KinWork.dJ.dot(dJ_ext) > 0 ) teta *= -1;
                
                dMatRot = AngleAxisd( teta,axe );
		
                OverallRotation *= dMatRot;	
		
		// below I want to update Coors1 with the new matrix:
		// Coors1[i] = MatRot * Coors1[i] for each i 
		tmpX = dMatRot[0][0]*X1 + dMatRot[0][1]*Y1 + dMatRot[0][2]*Z1 - X1;
		tmpY = dMatRot[1][0]*X1 + dMatRot[1][1]*Y1 + dMatRot[1][2]*Z1 - Y1;
		tmpZ = dMatRot[2][0]*X1 + dMatRot[2][1]*Y1 + dMatRot[2][2]*Z1 - Z1;
		
		X1 = tmpX;
		Y1 = tmpY;
		Z1 = tmpZ;
		                
		double dEkin0 = KinWork.dEkin;
                KinWork.set(X0,Y0,Z0,
			    X1,Y1,Z1,MassElements);
                                
                error = fabs( (KinWork.dEkin - dEkin0) / dEkin0 );
                n_it++;
		if (n_it<MaxStep) break;
         }
         
         ATOMISM_EXCEPT_IF( [&](){return  n_it>=MaxStep;},
			  "maximum number of step for J annihilation reached");
	 
         ATOMISM_LOGOUT();
	 return KinWork;
    }
    
}
#endif // MSENTITY_H
