/*
 <one line to give the library's name and an idea of what it does.>
 Copyright (C) 2013  Guillaume <email>
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

//! \file Entity.h definition of the class Entity, msVectorOfDofs, and msVectorOfPtrDof and msKineticWork

#ifndef ENTITY_H
#define ENTITY_H

#include <Environment.h>

namespace atomism {
    
    
	typedef Vector3D eigen::Vector3d;
	typedef Matrix3D eigen::Matrix3d;
	
    /** \class Entity
     *
     * \brief Describes the mass repartition with respect to (abstract) degrees of freedom
     *
     * The purpose of Entity is to compute the position of ponctual masses w/ degrees of freedom (DoF).
	 * The meaning of the DoF are abstract here: this is the purpose of derived classes to
	 * link the DoFs to the mass's position (for instance cartesian coordinates or z-matrix).
	 * The Entity class ensures that all the displacments generated by a modification of the Dofs
	 * conserve the linear and angular momentum. Hence, derived class just have to ensure
	 * the correct computation of the relative position of the elements (see Entity::updatePositions).
	 *
	 * The class obeys to the curiously recurring template pattern to avoid virtual method calls.
     */
	template<
    typename ScalarType         = double,
    typename StateType          = std::vector<ScalarType>,
    typename VectorPositionType = std::vector<ScalarType>,
    DerivedClass
    >
    class Entity {
        
        
        /** \class KineticWork
         *
         * The purpose of this class is to compute the kinetic work generated
         * by a displacments of the pontcual masses.
         */
        template<typename ScalarType=double,
        typename StateType=std::vector<ScalarType>
        >
        class KineticWork {
            
            friend class Entity;
            
        public:
            
            msKineticWork(){};
            
            /** \brief compute the kinetic work
             *
             * \param coors0 container of X, Y, Z coordinates of the elements at t0
             * \param coors0 container of X, Y, Z coordinates of the elements at t1
             * \param Masses Mass of the elements
             */
            void set(const Coordinates3D<StateType>& coors0,
                     const Coordinates3D<StateType>& coors1,
                     const StateType& Masses
                     );
        private:
            
            Vector3d dP;  	 //!< linear momentum generated by the displacments
            
            Vector3d dJ;  	 //!< angular momentum generated by the displacments
            
            ScalarType dEkin; //!< kinetic energy generated by the displacments
        };
        
        
    public:
        
        //! @name set methods
        //@{
        //! set the Dof number 'i' to a value 'd'
        void setDof(size_t i,double d);
    
        //@}
	    
        //-----------------------------------------------------
	    //-----------------------------------------------------
	    
	    //! @name get methods
        //@{
        //! return the position of the element 'i'
        Vector3d getPosition(size_t i) const;
        
        //! return the mass of the entity
        double getMass() const     { return _Mass; }
        
        const StateType& getMasses {return _MassElements;}
        
        const StateType& getDofs() { return _Dofs; }
        
        //! return a the Dof number 'i'
        double getDof(size_t i) const;
        
        //! number of elements
        size_t noOfElements() const;
        
        //! number of Dof
        size_t noOfDof()      const;
        
        
        //@}
	    
	    //-----------------------------------------------------
	    //-----------------------------------------------------
	    
	    //! @name compute methods
        //@{
	    
	    /** \brief computes the cartesian coordinates
	     *
	     * This method calls Derived->updatePosition and apply overall transformations
	     * to ensure linear and angular momentum conservation.
	     */
        KineticWork computeCartesianCoordinates();
	    
        void computeJacobian(const StateType& dq,const StateType& displacments);
	    
	    KineticWork displace( const StateType& dDofs );
	    
        /** \brief computes compute the principal moment of inertia.
	     *
	     * \param eigenvalues  stores the norms
	     * \param eigenvectors stores the directions, if zero the eigenvectors are not returned
	     */
        void computeEigenInertia(Vector3d* eigenvalues,Matrix3d* eigenvectors = 0) const;
        
	    //@}
        
   	    //! @name geometry analysis
        //@{
	    //! return the separation between the elements i, j
        double separation(size_t i,size_t j);
        
        //! return the angle between the elements i, j, k
        double angle(size_t i,size_t j,size_t k);
        
        //! return the dihedral angle between the elements i, j, k, l
        double dihedral(size_t i,size_t j,size_t k,size_t l);
	    //@}
	    
    protected:
        
	    //! @name construction
        //@{
	    
        Entity();
        
        Entity(size_t nelement, size_t ndof);
        
        /** \brief add an element
	     *
	     * \param mass mass of the elements in [amu]
	     */
        void addElement(double mass);
        
        /** \brief add a degree of freedom
	     *
	     * \param value initial value of the Dof, angles are in [radian], lengths in [Angstrom]
         */
        void addDof(double value);
	    
        //@}
        
    private:
        
        //! Store the DoF of the structure
        StateType _Dofs;
        
	    //! Store the mass of the elements in amu
	    StateType MassElements_;
	    
	    
        /** \brief Apply a translation to 'Coors1' so that no linear momentum is generated by the displacments from Coors0 to Coors1
         */
        void annihil_dP(const StateType& X0, const StateType& Y0, const StateType& Z0,
                        StateType& X1, const StateType& Y1, const StateType& Z1);
        
        /** \brief Apply a rotation to 'Coors1' so that no angular momentum is generated by the displacments from Coors0 to Coors1
         */
        KineticWork annihil_dJ(const StateType& X0, const StateType& Y0, const StateType& Z0,
                               StateType& X1, const StateType& Y1, const StateType& Z1);
	    
	    
        double dteta   = 0.01;
        double epsRel  = 1e-10 ;
        double epsAbs  = 1e-10 ;
        int    MaxStep = 50;
        
        double Mass_;
    };
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename ScalarType=double,
    typename StateType=std::vector<ScalarType>,
    DerivedClass
    >
    inline Entity::Entity(size_t nelement, const StateType& dofs const StateType& masses){
        
        ATOMISM_LOGIN();

        Dofs = clone(dofs);
        MassElements_ = clone(masses);
        
        ATOMISM_LOGOUT();
    };
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename ScalarType=double,
    typename StateType=std::vector<ScalarType>,
    DerivedClass
    >
    inline
    void Entity::computeDisplacments(const Coordinates3D<StateType>& coors0,
                                     const StateType& DofsNew,
                                     Coordinates3D<StateType>& displacments) const {
        
        ATOMISM_LOGIN();
        
        static_cast<DerivedClass*>(this)->computeRelativePositions(DofsNew, displacments);
        annihil_dP( coors0 , displacments );
        annihil_dJ( coors0 , displacments );
        
        displacments = displacments - coors0;
        ATOMISM_LOGOUT();
    }
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename ScalarType=double,
    typename StateType=std::vector<ScalarType>,
    DerivedClass
    >
    inline
    void Entity::annihilLinearMomentum(const Coordinates3D<StateType>& coors0,
                                       Coordinates3D<StateType>& coors1) const {
        
        ATOMISM_LOGIN();
        
        Vector3d Momentum = computeTotalLinearMomentum( coors0, coors1, MassElements_);
        translate( coors1, - Momentum);
        
        LOGGER_WRITE(Logger::DEBUG,stringstream("Delta CDG: ")
                     <<-Momentum[0]<<" "<<-Momentum[1]<<" "<<-Momentum[2]);
        
        ATOMISM_LOGOUT();
    }
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    
    template< typename ScalarType=double,
    typename StateType=std::vector<ScalarType>,
    DerivedClass
    >
    inline
    KineticWork Entity::annihilAngularMomentum(const Coordinates3D& coors0,
                                               Coordinates3D& coors1) const {
        
        ATOMISM_LOGIN();
        
        int    n_it   = 0;
        double conv   = 1;
        
        Vector3d axe,dJ_ext;
        Matrix3d rotMatrix;
        
        LOGGER_WRITE(Logger::DEBUG,
                     std::stringstream("Max number of step: ")<<MaxStep
                     <<"; relative residu: "<<epsRel<<"; absolu residu: "<<epsAbs);
        
        LOGGER_HEADER4COLUMNS(Logger::DEBUG,"it","dEc","dJ","dP");
        
        KineticWork<ScalarType> KinWork;
        KinWork.set(coors0,coors1,MassElements_);
        
        while( (KinWork.dJ.norm() > epsAbs) && (conv > epsRel) ) {
            
	        LOGGER_WRITE4COLUMNS(msLogger::DEBUG,
                                 n_it,KinWork.dEkin,KinWork.dJ.norm(),KinWork.dP.norm());
            
            double dEkin0 = KinWork.dEkin;
            rotMatrix = Eigen::AngleAxisd( dteta, KinWork.dJ / KinWork.dJ.norm() );
            
            dJ_ext    = computeAngularMomentum(dMatRot,coors1,MassElements_);
            
            teta      = - dteta * KinWork.dJ.dot(dJ_ext) / KinWork.dJ.norm();
            rotMatrix = Eigen::AngleAxisd( teta, KinWork.dJ / KinWork.dJ.norm() );
            
            rotate( coors1, dMatRot);
            
            KinWork.set(coors0,coors1,MassElements_);
            conv = fabs( (KinWork.dEkin - dEkin0) / dEkin0 );
            n_it++;
            if (n_it<MaxStep) break;
        }
        
        ATOMISM_EXCEPT_IF( [&](){return  n_it>=MaxStep;},
                          "maximum number of step for J annihilation reached");
        
        ATOMISM_LOGOUT();
        return KinWork;
    }
    
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------

    template< typename ScalarType=double,
    typename StateType=std::vector<ScalarType>,
    typename VectorPositionType = std::vector<ScalarType>,
    DerivedClass
    >
    inline
    void computeJacobian(const StateType& DofsValues,
                         const StateType& dq,
                         Environment& environment ) const {
    
        ATOMISM_LOGIN();
        
        ATOMISM_EXCEPT_IF( [&](){return dq.size()!=DofsValues;},
                          "dq.size()!=DofsValues");
        
        ATOMISM_EXCEPT_IF( [&](){return jacOfDofs.size() != n*n; },
                          "jacobianOfDofs.size()!=nDof*nDof");
        
        size_t n = environment.nDofs;
        auto& jacOfDofs  = environment._JacobianOfDofs;
        auto& jacOfDispl = environment._JacobianOfDisplacments;
        
        computeRelativePositions(DofsValues, environment._Positions);
        
        for(int i = 0; i < n ; ++i)
            
            threads.push_back(std::thread([&this](){
                
                slice[i]( jacOfDofs ) = DofsValues + dq * (vex::element index() == i);
                
                this->computeDisplacments( environment._Positions ,
                                           slice[i](jacOfDofs) ,
                                           slice[i](jacOfDispl) );
            }));
        
        ATOMISM_LOGOUT();
    }

    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------

    template< typename ScalarType=double,
    typename StateType=std::vector<ScalarType>,
    typename VectorPositionType = std::vector<ScalarType>,
    DerivedClass
    >
    inline
    void makeDisplacment(const StateType& DofsValues,
                         Environment& environment ) const {
        
        ATOMISM_LOGIN();
        
        this->computeDisplacments( environment._Positions ,
                                   DofsValues ,
                                   environment._Displacments );
        
        environment._Positions += environment._Displacments;
        
        ATOMISM_LOGOUT();
    }
    
}
#endif // MSENTITY_H
